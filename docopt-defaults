#!/usr/bin/env gawk -f
# SPDX-License-Identifier: MIT
# Copyright 2025 Erik Heckman
#
#
# docopts-defaults  v0.2.0
#
#
# Substitutes defaults in docopts help-version text using values
# fomr config files and environment variables.
#
#
# Usage: docopts-defaults [config-file...] help-version-file
#
# Use - to read the help-version text from standard in.
#
#
# Extension to docopts syntax:
#
# In addition to [default: VALUE], deocopts-defaults supports the
# following settings for each option:
#
#   [config: KEY], [config-: KEY]:
#               if KEY is defined in one of the config files, then
#               use its last-defined value as the default.
#
#   [env: VARNAME], [env-: VARNAME]
#               If an environment variable with the name VARNAME
#               exists, then use its value as the default.
#               (Overrides default config value.)
#
# The versions with the - suffix will not appear in the help text.
#
#
function die(reason, message, where){
	switch (reason) {
	case "CONFIG":
		message="Configuration parsing error. "\
		"Each line must be in KEY=VALUE format. "\
		"VALUE may not span multiple lines. "\
		"Values with whitespace must be quoted "\
		"with either double or single quotes. "
		"There is no escape character. "
		break
	case "BAD_DIRECTIVE":
		message="Invalid directive: "$message\
		"\nIt should be one of 'env:', 'config:', or 'default:"
		break
	case "NO_DEFAULT":
		message="Option '"OPTION"' does not have a default value. "\
		"All options that take an argument must have a default value."
		break
	default:
		message=reason?reason:"Undefined Error"
		reason=UNDEFINED
	}
	where="on line "FNR" of file '"FILENAME"'"
	printf("ERROR %s:%s\n    %s\n",where,$0,message) #> "/dev/stderr"
	exit EXIT_CODE["reason"]?EXIT_CODE["reason"]:1
}
function get_default(default){
	return HAS_ARG?default:(default~FALSY)?"true":"false"
}
function directive_replacement(source, pretext,  value){
	if (source ~ HIDDEN_DIRECTIVE) return
	value=\
		(source == "default")?
			get_default(DEFAULTS[SET_BY]):
		(source == SET_BY)?\
			DIRECTIVES[source]", overriding: "DEFAULTS["default"]:\
		(source in DEFAULTS)?
			value=DIRECTIVES[source]"="DEFAULTS[source]:\
		DIRECTIVES[source]
	# add line-wrapping here using "pretext" to generate indent
	return "["source": "value"]"

}
function print_buffer_line(line){
	# only options process directives (for now)
	if (OPTION && match(line,DIRECTIVE_REGEX,RARRAY)) {
		line=directive_replacement(RARRAY[2],RARRAY[1])
		line=RARRAY[1] line RARRAY[4]
		if (line !~ UNBLANK) return
	}
	print(line)
}
function set_defaults(){
	if (!("config" in DIRECTIVES)) {
		DIRECTIVES["config"]=DIRECTIVES["config-"]
	}
	if (!("env" in DIRECTIVES)) {
		DIRECTIVES["env"]=DIRECTIVES["env-"]
	}
	delete DEFAULTS
	SET_BY="default"
	DEFAULTS["default"]=\
		("default" in DIRECTIVES)?DIRECTIVES["default"]:\
		(!HAS_ARG)?false:die("NO_DEFAULT")
	if (DIRECTIVES["config"] in CONFIG) {
		DEFAULTS["config"]=CONFIG[DIRECTIVES["config"]]
		SET_BY="config"
	}
	if (DIRECTIVES["env"] in ENVIRON) {
		DEFAULTS["env"]=ENVIRON[DIRECTIVES["env"]]
		SET_BY="env"
	}
}
function flush_buffer(){
	if (OPTION) set_defaults()
	for (i in BUFFER) print_buffer_line(BUFFER[i])
	delete BUFFER
	BUFFER_LENGTH=0
}
function new_buffer(new_option, has_arg, i){
	flush_buffer()
	OPTION=new_option
	HAS_ARG=has_arg
	delete DIRECTIVES
	add_line_to_buffer()
}
function add_line_to_buffer(){
	BUFFER[++BUFFER_LENGTH]=$0
	# only options process directives (for now)
	if (OPTION && match($0,DIRECTIVE_REGEX,RARRAY)) {
		DIRECTIVES[RARRAY[2]]=RARRAY[3]
	}
	next
}
function debug(message){ printf("%s:%s:%s\n",FILENAME,FNR,message) }
BEGIN{
	# sorts arrays by keys, as strings, ascending
	PROCINFO["sorted_in"]="@ind_str_asc"
	# matches [default: VALUE] etc
	DIRECTIVE_REGEX="^(.*)\\[(default|config-?|env-?): (.*)]([^]]*)$"
	UNBLANK="[^[:space:]]"
	HIDDEN_DIRECTIVE="-$"
	FALSY="^(|false|0)$"
	CONFIG_LINE_REGEX="^[[:space:]]*([^[:space:]]*)[[:space:]]*=(.*)$"
}
BEGINFILE {
	if (ERRNO) nextfile # this is supposed to work in Gnu Awk
	if (ARGV[ARGC-1]==FILENAME) HELP_VERSION_TEXT=1
}

!HELP_VERSION_TEXT {
	# still reading config files

	if (/^[[:space:]]*(#|$)/)
		{} # do nothing for commented or blank lines
	else if (match($0,CONFIG_LINE_REGEX,RARRAY))
		CONFIG[RARRAY[1]]=RARRAY[2]
	else
		die("CONFIG",RARRAY[1]":"RARRAY[2])
	next
}


(POST_OPTIONS_SECTION){
	# stop processing
	add_line_to_buffer()
}
(!OPTIONS_SECTION){
	# check for start of Options:
	if(/^[[:space:]]*Options:/) OPTIONS_SECTION=1
	add_line_to_buffer()
}

$0=="----"{
	# end of help section
	POST_OPTIONS_SECTION=1
	POST_HELP_SECTION=1
	new_buffer()
}

match($0,/^[[:space:]]*(-[^[:space:]]+[[:space:]][^[:space:],-]+(,|[[:space:]])[[:space:]]*)?--([^[:space:]]+)[[:space:]][^[:space:]]+/,RARRAY){
	# long option with value, with possible short option as well
	new_buffer(RARRAY[3],1)
}

match($0,/^[[:space:]]*-([^[:space:],]+)[[:space:]][^[:space:]]/,RARRAY){
	# short option with value
	new_buffer(RARRAY[1],1)
}

match($0,/^[[:space:]]*(-[^[:space:],]+(,|[[:space:]])[[:space:]]*)?--([^[:space:]]+)[[:space:]]( {2,}|[[:space:]]*$)/,RARRAY){
	# long flag, with possible short flag as well
	new_buffer(RARRAY[3],0)
}


match($0,/^[[:space:]]*-([^[:space:]]+)([[:space:]]{2,}|[[:space:]]*$)/,RARRAY){
	# short flag
	new_buffer(RARRAY[1],0)
}

# Options: section ends on a blank line
# or a non-option-defining line that is insufficiently intented
# we're considering 4 whitespace characters an insufficent indent
/^$|^[[:space:]]{0,4}[^[:space:]-]/{
	# end of options section
	POST_OPTIONS_SECTION=1
	new_buffer()
}

{
	# option description
	add_line_to_buffer()
}

END{ flush_buffer() }
