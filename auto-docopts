#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright 2025 Erik Heckman
#
#
# auto-docopts  v0.1.0
#
# a wrapper for docopts <https://github.com/docopt/docopts>
# that generates settings from the header comment
#
#
# Usage:  auto-docopts [OPTIONS] FILE [DOCOPT-OPTIONS] : [ARGUMENTS...]
#
# Calls docopts with help and version information parsed
# from the header comment of FILE, passing along the
# specified DOCOPT-OPTIONS and ARGUMENTS.
#
# Options: (none as of yet)
# todo: add these options...
#    --config-path PATH    Colon-deliminated configuration files.
#                          Earlier files are overridden by later ones.
#                          Non-existent files are silently ignored.
#    --env PREFIX          Create an environment variable with the specified
#                          prefix for each option. The remainder of the variable
#                          name is generated by converting the option name to
#                          upper case. Illegal characters ([^A-Za-z0-9_]) will
#                          then be replaced with underscores.
#    --delimiter DELIM     Use DELIM as the delimiter to indicate directives
#                          that are extensions to docopts. Set to empty
#                          string to disable extensions completely.
#                          [default: '##']
#    --help                Show this help message and exit.
#    --version             Show version information and exit.
#

# auto-docopts should be eval'd from a script as in this example,
# which saves the options in an an associative array named OPTS:
#     eval "$(auto-docopts $0 -A OPTS : "$@")"
#
# The help text is gathered from a comment starting with
# the comment "Usage: PROGRAM" and ends with the first
# blank or uncommented line.
#
# The version string is built beginning with PROGRAM read from
# the usage text. The comments before the usage are scanned
# for version, copyright, and license information, which is
# formatted and added to the version string
#

# PRINT_VERSION will be interpreted by gawk. It must contain a function
# that prints the version string; it must have the following header:
#   print_version(NAME, VERSION, COPYRIGHT, LICENSE)
# It will be called with the following arguments:
#   NAME       name of the program as it appears in the Usage: comment line
#   VERSION    version without leading 'v' or 'version'
#   COPYRIGHT  copyright without leading '(C)' or 'Copyright'
#   LICENSE    license without leading ...'License'... or trailing 'License'
#
# This code is the last thing executed by gawk so there is no need to worry
# about clobbering global variables, such as OFS.
PRINT_VERSION='
function print_version(NAME, VERSION, COPYRIGHT, LICENSE){
	OFS="\n"
	print( \
		VERSION?NAME " v" VERSION:NAME, \
		(COPYRIGHT? "Copyright " COPYRIGHT (LICENSE? ", ":""):"") \
		(LICENSE? "License: " LICENSE:"") \
	)
}
'

set -euo pipefail
# set -x

: "${GNU_AWK:=gawk}" # uses match function with array parameter

# shellcheck disable=SC2154 # don't understand why status is not set?
trap 'status=$?; ! ((status)) || echo "exit $status # for the enwrapping eval"' EXIT

main(){
	local arg filename="${1-}"
	while
		arg="${1-}"
		shift
	do
		case "$arg" in ( [!-]*) filename="$arg"; break;;
		( -- ) filename="${1-}"; shift; break;;
		# todo: ( --config-path ) config_path="$1"; shift;;
		# todo: ( --env-prefix ) env_prefix="$1"; shift;;
		# todo: ( --delimiter ) delimiter="$1"; shift;;
		# todo: ( --help ) help_exit;;
		# todo: ( --version ) version_exit;;
		( -* ) die "Unknown option: $arg" 64;;
		esac
	done

	[[ -n "$filename" ]] ||
		die "No file specified." 64

	raw_help="$(docopt_header "${filename}")" ||
		die "Failed to read file '${filename}'" 66
	# { echo "$raw_help"; echo "--"; } >&2
	print_default_functions
	<<<"$raw_help"  print_default_function_calls
	# echo --- >&2
	<<<"$raw_help" expand_help_defaults |
	docopts --help - --version - "${@}"
}

# shellcheck disable=SC2016  # awk will be doing the expansion
expand_help_defaults(){
	"$GNU_AWK" \
		-v IGNORECASE=1 \
		-F'##' \
'
function default_string(value){
	return("[default: "strip_quotes(value)"]")
}
# strips pair of either single or double quotes around string,
# but only if there are no spaces in it
function strip_quotes(str){
	match(str,/^("([^[:space:]]+)")$/,matches)
	match(str,/^("([^[:space:]]+)"|'\''([^[:space:]]+)'\'')$/,matches)
	return(matches[2]?matches[2]:matches[3]?matches[3]:str)
	return str
}
$0=="----"{version=1}
(version){print;next}
!($2){print;next}
{
	match($2,/ def(ault)?:(.*)/,matches)
	$2=(matches[0])?default_string(matches[2]):""
	if($1$2~/[^[:space:]]/)print($1 $2)
}
'
}

# print_functions(){ sed -n "$(printf '/^%s()/,/^}/p;' "$@")" "$0"; }
print_default_functions(){
# 	print_functions set_option_default set_flag_default setup_defaults function_stub
# }
# shellcheck disable=SC2016  # this is for an eval
echo '
function_stub(){ echo "DEBUG: call to stubbed function: ${FUNCNAME[1]} ${*@Q}" >&2; }
set_option_default(){ function_stub "$@"; }
set_flag_default(){ function_stub "$@"; }
setup_defaults(){ function_stub "$@"; }
'
}

# shellcheck disable=SC2016  # awk will be doing the expansion
print_default_function_calls(){
		"$GNU_AWK" \
		-v IGNORECASE=1 \
		-F'##' \
'
function print_function(){
	if(OPT){
		# escape single quotes in OPT
		gsub("'\''","'\'\\\\\'\''",OPT)
		# wrap OPT in single quotes
		printf("set_%s_default '\''%s'\'' %s\n",HAS_ARG?"option":"flag",OPT,DEFS)
	} else if(DEFS){
		printf("setup_defaults %s\n",DEFS)
	}
}
function matched_option(opt,has_arg){
	if(!opt){ printf("WARNING: matched option %s(%s) in: %s",opt,has_arg,$0) > "/dev/stderr"; return }
	print_function()
	OPT=opt; HAS_ARG=has_arg; DEFS=""
	check_defs()
}
END{ print_function() }

function check_defs(){
	if($2)DEFS=DEFS" "$2
	next
}

# end of usage
$0=="----"{exit}

# long option with value, with possible short option as well
match($0,/^[[:space:]]*(-[^[:space:]]+[[:space:]][^[:space:],-]+(,|[[:space:]])[[:space:]]*)?--([^[:space:]]+)[[:space:]][^[:space:]]+/,matches){
	matched_option(matches[3],1)
	check_defs()
}

# short option with value
match($0,/^[[:space:]]*-([^[:space:],]+)[[:space:]][^[:space:]]/,matches){
	matched_option(matches[1],1)
	check_defs()
}

# long flag, with possible short flag as well
match($0,/^[[:space:]]*(-[^[:space:],]+(,|[[:space:]])[[:space:]]*)?--([^[:space:]]+)[[:space:]]( {2,}|[[:space:]]*$)/,matches){
	matched_option(matches[3],0)
	check_defs()
}

# short flag
match($0,/^[[:space:]]*-([^[:space:]]+)([[:space:]]{2,}|[[:space:]]*$)/,matches){
	matched_option(matches[1],0)
	check_defs()
}

# check default definitions even if option not matched
{ check_defs() }
'
}

# read help and usage information from the script specified in $1
# and print to stdout in a form that can be passed to docopts
#
# it does not parse any custom formatting
#
# shellcheck disable=SC2016  # awk will be doing the expansion
docopt_header(){
	# adjust spacing so that the opening ' is on a line ending with 1
	# that will make it easier to locate error in the gawk code
	"$GNU_AWK" \
		-v NAME="${name-}" \
		-v VERSION="${version-}" \
		-v COPYRIGHT="${copyright-}" \
		-v LICENSE="${license-}" \
		-v USAGE="${usage-}" \
		-v IGNORECASE=1 \
		-F'##' \
		-f <(cat <<'EOF'
# skip shebangs
/^#!/{next}

# the end of the usage section
/^[^#]|^$/{if(USAGE_INDENT)exit}

# the beginning of the usage section
!USAGE_INDENT && match($0,/^#[[:space:]]*usage:[[:space:]]*([^[:space:]]+)/,matches){
	NAME=matches[1]
	USAGE_INDENT=index($0,"u")
	USAGE=""
}

# currently reading the usage section
USAGE_INDENT{
	print(substr($0,USAGE_INDENT))
	next
}

# line contains the copyright
match($0,/#.*(copyright |\( ?c ?\) ?|copyright ?\( ?c ?\) ?) *(.*)$/,matches){
	COPYRIGHT=matches[2]
	next
}
# line contains the license specification
match($0,/^#[[:space:]]*([^[:space:]]*)[[:space:]]*License(-Identifier)?:? *([^[:space:]]*)/,matches){
	LICENSE=matches[3]?matches[3]:matches[1]
	next
}
# line contains version
match($0,"^# *[^[:space:]]* *v((er)?sion)?:? ?(.*)$",matches){
	VERSION=matches[3]
	next
}
EOF
echo "${PRINT_VERSION}"
echo 'END{
	print("----")
	print_version(NAME,VERSION,COPYRIGHT,LICENSE)
}'
) "$1"
}

die(){
	echo "autodocopts error: $1" >&2
	"$GNU_AWK" -F '# ?' '$1{exit}/^#!/{next}{print $2}' "$0" >&2
	exit 64
}

main "$@"
#
